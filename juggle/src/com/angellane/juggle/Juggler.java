package com.angellane.juggle;

import java.io.IOException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.nio.file.Paths;
import java.util.*;
import java.util.function.Predicate;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class Juggler {
    private JuggleClassLoader loader;

    private Collection<Class> classesToSearch;

    public Juggler(String[] jars, String[] mods) {
        if (jars == null) jars = new String[] {};
        if (mods == null) mods = new String[] {};

        // TODO: add modules here too?

        URL[] urls = Arrays.stream(jars)
                .flatMap((String path) -> {
                    try {
                        return Stream.of(Paths.get(path).toUri().toURL());
                    } catch (MalformedURLException ex) {
                        return Stream.empty();
                    }
                })
                .toArray(URL[]::new);

        loader = new JuggleClassLoader(urls);

        classesToSearch = Arrays.stream(jars)
          .flatMap((var jarName) -> classesInJar(jarName).stream())
          .flatMap((var className) -> {
              try {
                  return Stream.of(loader.loadClassWithoutResolving(className));
              }
              catch (ClassNotFoundException ex) {
                  System.err.println("Warning: class " + className + " not found");
                  return Stream.empty();
              }
          })
          .collect(Collectors.toList());
    }

    // Returns list of class names within a JAR.  Note: these class names might not be valid Java identifiers,
    // especially in the case of inner classes or JAR files generated by something other than the Java compiler.
    public List<String> classesInJar(String filename) {
        try (JarFile file = new JarFile(filename)) {
            var CLASS_SUFFIX = ".class";
            return file.stream()
                    .filter(Predicate.not(JarEntry::isDirectory))
                    .map(JarEntry::getName)
                    .filter((var s) -> s.endsWith(CLASS_SUFFIX))
                    .map((var s) -> s.substring(0, s.length() - CLASS_SUFFIX.length()))
                    .map((var s) -> s.replace('/', '.'))
                    .collect(Collectors.toList());
        } catch (IOException e) {
            System.err.println("Couldn't read JAR file: " + filename + "; ignoring.");
            return Collections.emptyList();
        }
    }

    public Class classForTypename(String typename) {
        // TODO: handle arrays
        // TODO: think about Generics
        return switch (typename) {
            case "void"    -> Void.TYPE;
            case "boolean" -> Boolean.TYPE;
            case "char"    -> Character.TYPE;
            case "byte"    -> Byte.TYPE;
            case "short"   -> Short.TYPE;
            case "int"     -> Integer.TYPE;
            case "long"    -> Long.TYPE;
            case "float"   -> Float.TYPE;
            case "double"  -> Double.TYPE;
            default        -> {
                try {
                    yield loader.loadClassWithoutResolving(typename);
                } catch (ClassNotFoundException e) {
                    Class defaultType = Object.class;

                    System.err.println("Warning: couldn't find class: " + typename
                                        + "; using " + defaultType + " instead");
                    yield defaultType;
                }
            }
        };
    }

    public Method[] findMethods(String[] paramTypenames, String returnTypename) {
        Class[] paramTypes = Arrays.stream(paramTypenames).map(this::classForTypename).toArray(Class[]::new);
        Class returnType = returnTypename == null ? Void.class : classForTypename(returnTypename);

        return findMethods(List.of(paramTypes), returnType);
    }

    public Method[] findMethods(List<Class> queryParamTypes, Class queryReturnType) {
        System.err.println("Searching for: "
                + queryParamTypes.stream().map(Class::getCanonicalName).collect(Collectors.joining(" -> "))
                + " -> " + queryReturnType.getCanonicalName());

        return classesToSearch.stream()
                .flatMap((var c) -> {
                    try {
                        return Arrays.stream(c.getDeclaredMethods());
                    } catch (NoClassDefFoundError e) {
                        // This might be thrown if the class file references other classes that can't be loaded.
                        // Maybe it depends on another JAR that hasn't been specified on the command-line with -j.
                        System.err.println("*** Ignoring class " + c + ": " + e);
                        return Stream.empty();
                    }
                })
                .filter((var m) -> doesMethodMatch(queryParamTypes, queryReturnType, m))
                .toArray(Method[]::new);
    }

    public boolean doesMethodMatch(List<Class> queryParamTypes, Class queryReturnType, Method m) {
        List<Class> methodParamTypes = new LinkedList<>();

        // TODO: what about constructors?

        // For instance methods, treat the declaring class as a parameter
        if (Modifier.STATIC != (m.getModifiers() & Modifier.STATIC))
            methodParamTypes.add(m.getDeclaringClass());

        methodParamTypes.addAll(Arrays.asList(m.getParameterTypes()));
        Class[] methodParamTypeArr = methodParamTypes.stream().toArray(Class[]::new);

        Class methodReturnType = m.getReturnType();

//        System.out.println("Checking: "
//                + m.getDeclaringClass() + "." + m.getName() + " :: "
//                + methodParamTypes.stream().map(Class::getCanonicalName).collect(Collectors.joining(" -> "))
//                + " -> " + methodReturnType.getCanonicalName());

        // Now for the big questions: do the parameter types match? Does the return match?

        Iterator<Class> queryTypeIter = queryParamTypes.iterator();

        return queryParamTypes.size() == methodParamTypes.size()
                && methodParamTypes.stream().allMatch((Class mpt) -> mpt.isAssignableFrom(queryTypeIter.next()))
                && queryReturnType.isAssignableFrom(methodReturnType)
                ;
    }

    private static class JuggleClassLoader extends URLClassLoader {
        public JuggleClassLoader(URL[] urls) {
            super(urls);
        }

        public Class loadClassWithoutResolving(String className) throws ClassNotFoundException {
            return super.loadClass(className, false);
        }
    }
}
