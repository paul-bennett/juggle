package com.angellane.juggle.source;

import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.file.Path;
import java.util.Optional;
import java.util.function.Predicate;
import java.util.jar.JarEntry;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class JarFile extends Source {
    private final static String CLASS_SUFFIX = ".class";
    private final static String MODULE_INFO = "module-info.class";

    private final String jarName;
    private URL jarURL;

    public JarFile(String jarName) {
        this.jarName = jarName;

        try {
            jarURL = Path.of(jarName).toUri().toURL();
        } catch (MalformedURLException ignored) {}
    }

    @Override
    public Optional<URL> configure() {
        return Optional.of(jarURL);
    }

    @Override
    public Stream<Class<?>> classStream() {
        Stream<Class<?>> ret = null;

        // Returns stream of class names within a JAR.  Note: these class names might not be valid Java identifiers,
        // especially in the case of inner classes or JAR files generated by something other than the Java compiler.
        try (java.util.jar.JarFile file = new java.util.jar.JarFile(jarName)) {
            ret = file.stream()
                    .filter(Predicate.not(JarEntry::isDirectory))
                    .map(JarEntry::getName)
                    .filter(s -> s.endsWith(CLASS_SUFFIX))
                    .filter(s -> !s.endsWith(MODULE_INFO))
                    .map(s -> s.substring(0, s.length() - CLASS_SUFFIX.length()))
                    .map(s -> s.replace('/', '.'))
                    .map(n -> getJuggler().loadClassByName(n))
                    .flatMap(Optional::stream)
                    // Collect & create a new stream now so that the JAR file is read before it's closed
                    .collect(Collectors.toList()).stream();
        } catch (IOException ignored) {}

        return ret;
    }
}
