 * Consider generics -- is it even possible due to type erasure?
 * Consider arrays
 * Are member variables really fns?
     - get :: ClassType -> MemberType
     - set :: ClassType -> MemberType -> void
 * How to handle constructors?  As funcs that return an object of that type?
 * Access; private, protected, package
     - maybe this should be a command-line flag, default = only public
 * Allow type placeholders & "don't care" types
 * Is 'void' really a type?
 * Matches should work with any permutation of parameters
 * What about currying?
     - search for: Foo -> Bar -> Baz might match Foo -> (Bar -> Baz)
       (Java kind of allows this return type with Functional Interfaces)
 * Try alternative syntax for command-line
     - i.e. express query in a more natural way, rather than:
          -p foo -p bar -r baz
     - maybe like a Java declaration
          "baz myfunc(foo f, bar b)"
       where "myfunc", "f" and "b" are ignored bits of text
     - or would a lambda-inspired syntax work?
          "(foo, bar) -> baz"
     - Haskell-like?
          "foo -> bar -> baz"
 * At present we treat everything as boxed (e.g. long becomes Long).
   Is that the right approach?
 * Should sort results naturally
     - Exact matches first
     - Permutations of parameters and partial matches later
     - What about supertype params and subtype returns?
     - Box/unbox cost?
     - Prefer member funs over statics?
 * How should inner classes be searched?
 * Optional matching algorithm?
     - exact match vs assignment-compatible
     - configurable as to whether to ignore optional args
 * Does this solve my original two questions?
     1. "I have a Foo. What can I do with it?"
     2. "How do I get a Bar?"
